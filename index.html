<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Ted Chen&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="再不疯狂，我们就老了">
<meta property="og:type" content="website">
<meta property="og:title" content="Ted Chen's blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Ted Chen's blog">
<meta property="og:description" content="再不疯狂，我们就老了">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Ted Chen's blog">
<meta name="twitter:description" content="再不疯狂，我们就老了">
  
    <link rel="alternative" href="/atom.xml" title="Ted Chen&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <script src="http://libs.baidu.com/jquery/1.9.0/jquery.js"></script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img lazy-src="http://tp3.sinaimg.cn/1503812550/180/5742227485/1" class="js-avatar">
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Ted Chen</a></h1>
		</hgroup>

		
		<p class="header-subtitle">时间不老，我们不散</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tags/随笔">随笔</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/TedMore" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/1503812550" title="weibo">weibo</a>
					        
								<a class="mail" target="_blank" href="mailto://chentao623tmc@126.com" title="mail">mail</a>
					        
								<a class="zhihu" target="_blank" href="http://www.zhihu.com/" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Foundation/" style="font-size: 10px;">Foundation</a> <a href="/tags/Framework/" style="font-size: 10px;">Framework</a> <a href="/tags/Objective-C/" style="font-size: 13.33px;">Objective-C</a> <a href="/tags/Swift/" style="font-size: 10px;">Swift</a> <a href="/tags/code/" style="font-size: 10px;">code</a> <a href="/tags/hexo/" style="font-size: 16.67px;">hexo</a> <a href="/tags/iOS/" style="font-size: 20px;">iOS</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/杂谈/" style="font-size: 10px;">杂谈</a> <a href="/tags/解决方案/" style="font-size: 10px;">解决方案</a> <a href="/tags/随笔/" style="font-size: 13.33px;">随笔</a> <a href="/tags/面试题/" style="font-size: 10px;">面试题</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://dulingkang.github.io">Shawn Du</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://www.zybuluo.com/mdeditor">Markdown编辑器</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://coderq.com/">码农圈</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://wuchong.me/">The author&#39;s blog of Jacman</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://ibruce.info/">不如的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://yangxiaolei.me/">Yangxiaolei&#39;s blog</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://lukang.me/">KangLu&#39;s Blog</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://haomwei.com/">屠城｜屠夫9441的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.matrix67.com/blog/">Matrix67</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.cnblogs.com/1208/">1208博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">不喜欢分享的人不一定是最帅的，但喜欢分享的人一定是最帅的。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Ted Chen</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://tp3.sinaimg.cn/1503812550/180/5742227485/1" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">Ted Chen</h1>
			</hgroup>
			
			<p class="header-subtitle">时间不老，我们不散</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags/随笔">随笔</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/TedMore" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/1503812550" title="weibo">weibo</a>
			        
						<a class="mail" target="_blank" href="mailto://chentao623tmc@126.com" title="mail">mail</a>
			        
						<a class="zhihu" target="_blank" href="http://www.zhihu.com/" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-lazy-iOS" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/20/lazy-iOS/" class="article-date">
  	<time datetime="2015-08-20T15:24:00.000Z" itemprop="datePublished">8月 20 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/20/lazy-iOS/">工程师的懒隋</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>原创 2015-08-19 尚传人 iOS开发 iOS开发</p>
<p>作者介绍</p>
<p>尚传人（@传人Joe），iOS 开发者，重度代码洁癖 + 处女座，喜欢思考与总结，爱刨根问底，追求整洁代码。</p>
<hr>
<p>懒惰被视为七宗罪之一，是个贬义词，但在一定场景下，懒惰变成了褒义词：在我看来，懒惰才是人类进步的关键，正是因为懒，才创造出各种各样的工具来提升效率。人们懒得走路，发明了自行车，后来懒得蹬车，就发明了汽车，最近连开车都懒得开了，于是出现了自动驾驶汽车。对于工程师而言，懒惰也分两种，这两种类型的懒惰会使工程师的成长出现截然不同的道路。</p>
<h2 id="有利的懒惰">有利的懒惰</h2><p>有利的懒惰是指讨厌重复而低效的任务，自己懒得做，就让工具做，将重复任务自动化。有利的懒惰能够极大地提高效率，节约时间。下面举几个例子：</p>
<h2 id="COCOAPODS">COCOAPODS</h2><p>CocoaPods 是开发 OS X 和 iOS 应用程序时一个第三方库的依赖管理工具。在 CocoaPods 出现之前，需要添加一个第三方库需要以下操作：</p>
<ol>
<li><p>下载第三方库的代码。</p>
</li>
<li><p>将第三方库的代码引入工程，并添加第三方库所需的 Framework。</p>
</li>
<li><p>解决库与库之间、库与工程之间的依赖关系，检测重复添加的 Framework。</p>
</li>
<li><p>如果第三方库有更新，需要将库从工程中删除，并重复上面的步骤。</p>
</li>
</ol>
<p>哦买噶，这些重复繁琐的工作能把人烦死，有些“懒惰”的工程师无法忍受这种情况，于是 CocoaPods 出现了，它能够自动下载配置文件中指定的第三方库，处理库与库之间的依赖关系，并通过新建一个 xcworkspace 的方式将第三方库同工程连接起来。哈利路亚，感觉整个世界清净了。</p>
<h2 id="ARC_与_BLOCK">ARC 与 BLOCK</h2><p>ARC 为什么会出现呢？因为在 MRC 下每次都要 retain/release 真是太麻烦了，而且还容易不配对导致内存泄露，估计苹果的工程师都写烦了，既然编译器能够识别出对象的生命周期，那就让编译器去做内存管理吧，简单省事。有人可能不放心把内存管理交给编译器，你放心，在识别对象声明周期这件事上，编译器比你厉害，再厉害的开发者也有可能因为一时疏忽而遗漏，但编译器不会。另外，会有人认为 ARC 会影响性能，这其实是不理解 ARC 的原理：ARC 不是垃圾回收，只是自动帮你写 retain/release 了，而且写 retain/relese 时不再经过消息传递，是直接调用对应的 C 函数，这会提升性能的。另外，对于工厂方法返回值，ARC 也 会做优化，不再将返回的对象放入 AutoReleasePool 了，而是直接返回，相当于调 alloc + init。所以放心的使用 ARC 吧，这种提高效率的东西为什么不用？</p>
<p>Block 为什么会出现呢？在我看来，是因为在使用回调函数时，每次使用变量都要将变量整合到一个结构体中，用 void * 指针的形式传递给回调函数的 context 参数，真是太麻烦了。编译器既然能识别出在回调函数里使用了哪些变量，就自动地跟回调函数整合成为一个对象吧，这样在回调函数中就能直接使用了。</p>
<h2 id="《IOS_开发进阶》中的脚本">《IOS 开发进阶》中的脚本</h2><p>唐巧的《iOS 开发进阶》中让我印象最深的是实战技巧里的一些脚本，例如删除未使用的图片资源、检查图片长宽是否是偶数等，虽然都是些简单操作，但是能提升效率，感觉很棒。</p>
<h2 id="我写过的一个自动部署工具">我写过的一个自动部署工具</h2><p>在中科院实习的时候，曾经负责开发维护一个嵌入式系统，代码是跑在一块 ARM 开发板上的，因此每次交叉编译过后需要通过 FTP 将包传到开发板上解压，并配置一下 rcS 启动脚本。开发阶段只是一块 ARM 板，手动部署就还好，后来变成了十五块 ARM 板，这下我不干了，手动部署会死人的，而且一旦程序有 Bug，就要重新部署一遍。于是“懒惰”的我写了一个自动部署工具，思路就是轮询目标 ARM 板的 IP 地址，针对每个 IP，先通过 FTP 将程序包上传，再通过 Telnet 输入解压程序包以及覆盖 rcS 启动脚本的指令，将整个过程自动化。由于懒得每次 IP 地址改变就重新编译程序，因此将 IP 地址、FTP 账户密码等信息从程序中抽出来，放到一个配置文件中，每次启动时读取（也算是一种依赖注入了）。同时也懒得每次 Telnet 输入的命令改变就重新编译程序，将 Telnet 要输入的命令也写到一个文本文件中，动态读取。写好了之后，手动部署估计要两个小时的活，一行命令搞定，感觉生活顿时美好了许多。</p>
<p>如果仔细观察，还有非常多的例子，其实要做到这一点与能力无关，与方向无关，与规模无关，只跟态度有关，包括个人与团队的态度。对于个人而言，遇到重复工作，是就这样低效地重复下去，还是思考用自动化提高效率？对于团队而言，是否给成员时间来完成一些能够提高效率的工具？工程师文化越是浓厚的团队，各种工具就越多，效率就越高。总之，人并不擅长做重复枯燥的工作，而这些工作恰恰是机器擅长的，想办法交给机器去做吧，遵循 DIY：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Don’t Repeat Yourself!</span><br></pre></td></tr></table></figure></p>
<h2 id="不利的懒惰">不利的懒惰</h2><p>下面这些不利的懒惰会极大地妨碍我们成为优秀的工程师（在写下面的内容时，我也在不断反思自己，发现其实自己许多地方依然犯了懒惰的错误，边写边出汗，膝盖各种中箭。。。）：</p>
<h2 id="懒得搜索">懒得搜索</h2><p>我记得微博上有过一张亚一程 Laruence 一段群对话的截图，里面是这样说的：“不是我说你，这么简单的问题，你不 Google，不百度，来群里问，简直是舍近求远”。其实真正原因就是懒。在现在这个时代，搜索是无比强大的工具，想想看，世界那么大，就去搜一搜，你不会是第一个遇到问题的，也不会是最后一个遇到的，我觉得，Google + StackOverflow + Github + Dash 基本上能解决99%的问题。</p>
<p>我们经常会遇到搜索不到答案的过程，于是很多人就放弃了，回到了到处去问的老路上。其实搜索不到答案的原因有2点：1，我们没有正确描述以及抽象问题，找对关键字。2，我们没有用搜索引擎的思维思考。遇到搜索不到的情况时，不要放弃，努力思考如何修改关键字与描述，多试几次，虽然很痛苦，但痛苦说明我们的大脑在形成新的思维模式，一旦形成，我们的搜索会越来越准确，效率也会越来越高。</p>
<p>哦，对了，最后提醒一下，对于技术问题，还是避免使用百度吧，真的搜不到什么有用的东西。有人会说用 Google 还要科学上网，多麻烦，相比搜索到有效答案带来的收益，翻墙这点工作真不算什么，我们可是工程师啊，反思下是不是因为懒所以不愿意用 Google？</p>
<h2 id="懒得思考">懒得思考</h2><p>我们在学习一个知识的时候，要积极思考，不能死记硬背。一种框架/特性出现时，一定有它的原因，多想想为什么会出现？解决了什么样的问题？为什么要这样做？这样做的好处是什么？原理是什么？到底是如何实现的？保持强烈的好奇心，这会使我们不断发问，在回答问题时会不断思考，而只有不断的思考才能真正理解一个知识，从而能够更好的使用。</p>
<p>另外，我们在遇到问题后，往往会搜到解决方案只是简单的拷贝，不分析背后的原因，不分析解决方案会造成哪些影响。Bug 是那磨人的小妖精，这次不彻底搞清楚原因，下次它还会来烦我们，我们就会成为传说中的救火队长，哪里着火灭哪里，疲于奔命，但火却越灭越多。</p>
<h2 id="懒得阅读">懒得阅读</h2><p>现在不是知识匮乏，而是知识爆炸，如果想学习，有太多的东西可以学了：</p>
<ul>
<li><p>书：iOS 的经典书籍，随便一本都能让人受益匪浅。</p>
</li>
<li><p>博客：有太多优秀的博客了，那都是别人深思熟虑的精华，花数个小时写出来。</p>
</li>
<li><p>文档：很多时候，StackOverflow 回答问题的方式就是贴上一段官方开发文档上的文字，或者接口 API 的说明。用 Dash 或 Xcode 自带文档工具，越到不清楚的点就去看一看。</p>
</li>
<li><p>源码。Reading the Fucking SOURCE CODE 不是一句空话，源码之下无秘密。有些效果不知道怎么做，到 GitHub 上搜一搜，看懂了自己不就会了。</p>
</li>
</ul>
<p>总之，Stay Hungry，Stay Foolish！</p>
<h2 id="懒得动手尝试">懒得动手尝试</h2><p>看看这篇《Leveling Up》，纸上得来终觉浅，绝知此事要躬行，动手才是学习最有效的方法：</p>
<ul>
<li><p>在看别人教程时，把 Demo 下载，自己跑一跑，改改参数，或者自己尝试重新写一遍，效果绝对比只看要好。自己有疑问时或者有想法时，都可以写个 Demo 实验一下。</p>
</li>
<li><p>在看 Objective-C Runtime 原理时，亲自用 clang -rewrite-objc file.m 将 .m 文件转成 .cpp 文件看一看。用 Associated Object 给 Category 加属性时都自己写段代码试一试。</p>
</li>
<li><p>想看系统函数的调用情况，可以用 Method Swizzle 给一些系统方法加一些“装饰”，或者还可以用符号断点。没事干找台越狱手机用 Reveal 看看别人家的 App。</p>
</li>
</ul>
<h2 id="懒得改进优化">懒得改进优化</h2><p>唯一不变的就是变化。代码在最初时由于业务简单一般都很不错，但往往在增加新需求/需求变化时开始出现坏味道，因为需求的变化经常导致大环境变化，而不同环境下的实现是不同的，例如网站支持100人访问与支持100000人访问是两种实现方式，控件只支持一行显示与支持多行显示也是两种实现方式。PM 有时候意识不到需求变化背后隐含的环境变化对技术实现的影响，觉得不就是简单的改一下，有什么难的？对啊，把大象装冰箱里也只需要三步，有什么难的？为了应对这些变化，工程师有时需要对结构进行调整，保证结构的灵活，在下次变化来临时更从容，这种调整就是重构。重构不是洪水猛兽，重构可以很大，也可以很小，一切在于时间点，修改的时间点越早，成本就越低，不然就会欠下技术债。在逻辑的世界里，只分对错，欠下的一定会还。不要为了一时便利而忽略了可持续性，切记技术债是高利贷，利滚利，拖得时间越久，成本就越高，到最后一定会连本带利让欠债者赔个精光。</p>
<p>因此工程师在实现需求时一定要留出 Buffer 来处理结构变化引起的重构与遗留代码带来的技术债，不能懒，这样以后的需求才会更好做。而团队在每个迭代中也应考虑将一些技术债与优化作为需求加入到需求池中，不然代码的坏味道就开始在工程中弥漫，需求越做越慢，Bug 越做越多，为了速度，开始拼命加班招人，效率却越来越低，开始进入恶性循环。</p>
<h2 id="懒得总结">懒得总结</h2><p>在我看来，经验从来不是比拼总时间，而是比拼效果。有些人多年经验却不如有些人一年经验，这是为何？关键在于总结。就拿圣斗士星矢来说，如果单论时间，他能当上青铜圣斗士都很勉强了，为什么他能打败黄金圣斗士，因为他说过：圣斗士不会败给同一招两次！犯错掉进坑里不要紧，谁没有犯过错？但掉进两次掉进同一个坑就不太好了，而有效的经验能让我们以后不再犯相同或类似错误。</p>
<h2 id="如何克服这些问题">如何克服这些问题</h2><p>我仔细观察过一些优秀的 iOS 工程师，发现：</p>
<ul>
<li><p>每年都有 WWDC，大家都能看，但喵神 onevcat 总能写出高质量的笔记与总结。</p>
</li>
<li><p>同样是学 Objective-C，阳神孙源能玩出花来，挖掘出各种特性与原理。（我曾经在阳神的博客上问过一个问题，阳神告诉我他是通过反解汇编代码得出的，我就意识到自己犯了懒于尝试的错误了）</p>
</li>
<li><p>动画狂魔叶孤城_与动画小王子 KITTEN-YANG 的动画屌炸天，不用问他们为何如此屌，去他们的 GitHub 上看看他们各种尝试动画的 Demo 就知道了。</p>
</li>
<li><p>唐巧的《iOS 开发进阶》让我收获最多的不是里面的知识，而是他学习与总结的方式，我不断的反思自己，我平时学习时，是否能像他一样总结出一本自己的 iOS 学习笔记。</p>
</li>
</ul>
<p>还有许多优秀的 iOS 工程师这里就不一一举例了，我认为，这些优秀的 iOS 工程师并没有比你我聪明，跟我们一样只是普通人，但他们在上面这些事情上不懒惰，积极思考、尝试、总结，在同样的条件下收获多一点点，日积月累，于是他们变得优秀。不要小看这一点点，我们要相信积累的力量，水滴石穿啊，tinyfool 说过，这种积累所达到的层次，很难被人短时间追赶上，需要别人同样去积累，是非常具有竞争力的。</p>
<p>面对这些优秀的 iOS 工程师，我们经常会犯另一种懒惰的错误：我们总想加好友，攀交情，甚至用拉低姿态的方式，总觉得自己抱上大腿就能迅速成长，迅速变牛。这其实是种假象，是自己不自信不独立的表现。即使加了好友，他们能够答疑解惑，甚至手把手教，亲自帮忙解决问题又怎样，那还是别人的东西，自己没有任何成长，自己不就犯了懒惰的错误吗？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">学习与成长从来没有捷径，也只能靠自己！</span><br></pre></td></tr></table></figure></p>
<p>除了欣赏与钦佩这些优秀的人外，我觉得更重要的是默默地观察与努力，观察他们是如何成长的，学习他们的好习惯，努力提升自己，向他们看齐，当有一天达到了他们的水平之后，无需刻意培养，同他们自会相熟，因为优秀的人总是互相吸引互相欣赏，“臭味相投”，不是吗？</p>
<p>总之，借用《学 iOS 开发的一些经验》里的一段话来激励自己，努力成为一名“懒惰”而不懒惰的优秀工程师：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我觉得支撑我们不断探索和前进的动力不是兴趣，而是永不满足的好奇心，和对优雅代码的追求。</span><br></pre></td></tr></table></figure></p>
<h2 id="与技术无关的懒惰">与技术无关的懒惰</h2><p>最后提一下工程师非常常见的懒惰：懒得锻炼，不注意自己身体。在我看来，我们可以热爱编程，热爱自己的工作，热爱自己的事业，热爱自己的公司，但这些不是最重要的，最重要的是我们自己的身体与我们的家庭。为什么呢？因为对于公司而言，我们是可以替代的，无论我们多么牛，多么重要，少了我们，公司依然可以运作。但对于身体与家庭而言，我们是不可替代的！身体不是程序，不能重置，一旦身体坏了，就很难恢复，甚至继续恶化，伴随一生。一旦我们走了，我们的父母、配偶、子女就失去了唯一的我们，这带来的伤害与损失对于家庭而言是无法估量的，甚至为持续一辈子（看看那些失孤的老人，让人心碎啊）。孰重孰轻，我相信理智的工程师会做出自己的决定。</p>
<p>我这里不是说我们不要奋斗不要拼搏，这跟锻炼身体完全是互不影响的，锻炼身体甚至能让我们能够更好的拼搏与奋斗。我们不能学习现在敏捷的一些错误做法，只强调快，却忽略了可持续性（敏捷强调的是可持续性的快速迭代），所以不要拼一天的工作时长，留出点时间锻炼健身，我们都加过班，长时间加班加到后面其实脑子已经不够敏锐了，效率极低，对编程这种强脑力劳动是很不利的，易出问题，还不如回去跑跑步，早点休息，明天更高效完成就好了。有时候公司或团队的氛围就是不把工程师当人看，疯狂加班，幻想着靠十个女人怀孕一个月就能把孩子生出来，我觉得实在受不了就换一家吧，没什么大不了，开心健康地活着其实就是在赚钱。（医院才是真正的销金窟，钱到那个时候就是个数字，医院里充斥着痛苦、无助、绝望、麻木，唯独没有幸福，谁经历过谁知道）</p>
<p>另外，在工程师的眼里，既然一切都是逻辑，为什么不把自己的身体当做程序来调试与优化呢？一样的都有输入输出，对高热量食物防御式编程等，我曾经这样试过，成功减肥30斤，当我能够穿上一条许久都穿不上的裤子时，相信我，那种成就感比写100个牛逼程序或 GitHub 上有一个10000+ Star 的仓库都要强。</p>
<p>PS. 最近准备找工作，希望到一个比较注重代码质量与技术氛围的团队，求内推。我的微博（<a href="http://weibo.com/u/2464216170），GitHub（http://github.com/joeshang" target="_blank" rel="external">http://weibo.com/u/2464216170），GitHub（http://github.com/joeshang</a> ）。</p>
<hr>
<p>版权说明：作者已将本文章在微信公众平台的发表权，「独家代理」给本公众帐号。本文的打赏归原作者所有。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-iOS-Interview" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/07/19/iOS-Interview/" class="article-date">
  	<time datetime="2015-07-19T13:18:16.000Z" itemprop="datePublished">7月 19 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/19/iOS-Interview/">iOS面试题</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一个区分度很大的面试题">一个区分度很大的面试题</h2><p>考察一个面试者基础咋样，基本上问一个 @property 就够了：</p>
<h3 id="@property_后面可以有哪些修饰符？">@property 后面可以有哪些修饰符？</h3><ul>
<li>线程安全的:<ul>
<li>atomic,nonatomic</li>
</ul>
</li>
<li>访问权限的<ul>
<li>readonly,readwrite</li>
</ul>
</li>
<li>内存管理(ARC)<ul>
<li>assign,strong,weak,copy</li>
</ul>
</li>
<li>内存管理(MRC)<ul>
<li>assign,retain,copy</li>
</ul>
</li>
<li>指定方法名称<ul>
<li>setter=</li>
<li>getter=</li>
</ul>
</li>
</ul>
<h3 id="什么情况使用_weak_关键字，相比_assign_有什么不同？比如:">什么情况使用 weak 关键字，相比 assign 有什么不同？比如:</h3><ul>
<li>在ARC中,出现循环引用的时候,必须要有一端使用weak,比如:自定义View的代理属性</li>
<li>已经自身已经对它进行一次强应用,没有必要在强引用一次,此时也会使用weak,自定义View的子控件属性一般也使用weak;但b是也可以使用strong</li>
<li>weak当对象销毁的时候,指针会被自动设置为nil,而assign不会* assigin 可以用非OC对象,而weak必须用于OC对象</li>
</ul>
<h3 id="怎么用_copy_关键字？">怎么用 copy 关键字？</h3><ul>
<li>对于字符串和block的属性一般使用copy</li>
<li>字符串使用copy是为了外部把字符串内容改了,影响该属性</li>
<li>block使用copy是在MRC遗留下来的,在MRC中,方法内部的block是在在栈区的,使用copy可以把它放到堆区.在ACR中对于block使用copy还是strong效果是一样的</li>
</ul>
<h3 id="这个写法会出什么问题：_@property_(copy)">这个写法会出什么问题： @property (copy)</h3><h3 id="NSMutableArray_*array;">NSMutableArray *array;</h3><ul>
<li>添加,删除,修改数组内的元素的时候,程序会因为找不到对于的方法而崩溃.因为copy就是复制一个不可变NSArray的对象</li>
</ul>
<h3 id="如何让自己的类用_copy_修饰符？">如何让自己的类用 copy 修饰符？</h3><ul>
<li>你是说让我的类也支持copy的功能吗?</li>
<li><p>如果面试官说是:</p>
<ul>
<li>遵守NSCopying协议</li>
<li>实现 - (id)copyWithZone:(NSZone *)zone; 方法</li>
</ul>
</li>
<li><p>如果面试官说否,是属性中如何使用copy</p>
<ul>
<li>在使用字符串和block的时候一般都使用copy</li>
</ul>
</li>
</ul>
<h3 id="如何重写带_copy_关键字的_setter？">如何重写带 copy 关键字的 setter？</h3><ul>
<li>重写copy的setter方法时候,一定要调用一下传入的对象的copy方法,然后在赋值给该setter的方法对应的成员变量</li>
</ul>
<h3 id="这一套问题区分度比较大，如果上面的问题都能回答正确，可以延伸问更深入点的：">这一套问题区分度比较大，如果上面的问题都能回答正确，可以延伸问更深入点的：</h3><h3 id="@property_的本质是什么？ivar、getter、setter_是如何生成并添加到这个类中的">@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的</h3><ul>
<li>在普通的OC对象中,@property就是编译其自动帮我们生成一个私有的成员变量和setter与getter方法的声明和实现</li>
<li>我为了搞清属性是怎么实现的,曾经反编译过相关的代码,他大致生成了五个个东西</li>
<li>OBJC<em>IVAR</em>$类名$属性名称 该属性的偏移量</li>
<li>setter与getter方法对应的实现函数</li>
<li>ivar_list 就是成员变量列表</li>
<li>method_list 方法列表</li>
<li><p>prop_list 属性列表</p>
<p>也就是说我们每次在增加一个属性,系统都会在ivar_list中添加一个成员变量的描述,在method_list中增加setter与getter方法的描述,在属性列表中增加一个属性的属性的描述,然后计算该属性在对象中的偏移量,然后伸出setter与getter方法对应的实现,在setter方法方法中从偏移量的位置开始赋值,在getter方法中从偏移量开始取值,为了能够读取正确字节数,系统对象偏移量的指针类型进行了类型强转.</p>
</li>
</ul>
<h3 id="@protocol_和_category_中如何使用_@property">@protocol 和 category 中如何使用 @property</h3><ol>
<li>在protocol中使用property只会生成setter和getter方法声明,我们使用属性的目的,是希望遵守我协议的对象的实现该属性</li>
<li><p>category 使用 @property 也是只会生成setter和getter方法的声明,如果我们真的需要给category增加属性的实现,需要借助于运行时的两个函数</p>
<ol>
<li>objc_setAssociatedObject</li>
<li>objc_getAssociatedObject</li>
</ol>
</li>
</ol>
<h3 id="runtime_如何实现_weak_属性">runtime 如何实现 weak 属性</h3><p>这东西没有研究过,请你帮我介绍一下好吗?<br>每个人擅长的领域不一样，我们一般会从简历上找自己写擅长的技术聊，假如自己并不是很熟，最好别写出来或扯出来，万一面试官刚好非常精通这里就露馅了。</p>
<h2 id="Checklist">Checklist</h2><p>总结过些面试题，没坚持下去，后来把这些当 checklist，面试的时候实在没话聊的时候做个提醒，语言、框架、运行机制性质的：</p>
<h3 id="[※]@property中有哪些属性关键字？">[※]@property中有哪些属性关键字？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">同上</span><br></pre></td></tr></table></figure>
<h3 id="[※]weak属性需要在dealloc中置nil么？">[※]weak属性需要在dealloc中置nil么？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不需要,在ARC环境无论是强指针还是弱指针都无需在deallco设置为nil,ARC会自动帮我们处理</span><br></pre></td></tr></table></figure>
<h3 id="[※※]@synthesize和@dynamic分别有什么作用？">[※※]@synthesize和@dynamic分别有什么作用？</h3><ol>
<li>@property有两个对应的词，一个是@synthesize，一个是@dynamic。如果@synthesize和@dynamic都没写，那么默认的就是@syntheszie var = _var;</li>
<li>@synthesize的语义是如果你没有手动实现setter方法和getter方法，那么编译器会自动为你加上这两个方法。</li>
<li>@dynamic告诉编译器,属性的setter与getter方法由用户自己实现，不自动生成。（当然对于readonly的属性只需提供getter即可）。假如一个属性被声明为@dynamic var，然后你没有提供@setter方法和@getter方法，编译的时候没问题，但是当程序运行到instance.var =someVar，由于缺setter方法会导致程序崩溃；或者当运行到 someVar = var时，由于缺getter方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。</li>
</ol>
<h3 id="[※※※]ARC下，不显示指定任何属性关键字时，默认的关键字都有哪些？">[※※※]ARC下，不显示指定任何属性关键字时，默认的关键字都有哪些？</h3><ol>
<li><p>对应基本数据类型默认关键字是</p>
<p>atomic,readwrite,assign</p>
</li>
<li><p>对于普通的OC对象</p>
<p> atomic,readwrite,strong</p>
</li>
</ol>
<h3 id="[※※※]用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？">[※※※]用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</h3><ol>
<li>因为父类指针可以指向子类对象,使用copy的目的是为了让本对象的属性不受外界影响,使用copy无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本.</li>
<li>如果我们使用是strong,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性.</li>
</ol>
<h3 id="[※※※]@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？">[※※※]@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？</h3><p>如果没有指定成员变量的名称与自动生成一个属性同名的成员变量,如果指定的成员变量的名称,会生成一个指定的名称的成员变量,如果这个成员已经存在了就不再生成了.<br>如果是 @synthesize foo; 还会生成一个名称为foo的成员变量<br>如果是 @synthesize foo = _foo; 就不会生成成员变量了.</p>
<h3 id="[※※※※※]在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？">[※※※※※]在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？</h3><p>@synthesize主要就是用来生成setter,getter方法的实现,在@property被增强之后,其实已经很少使用@synthesize了,你知道@synthesize的其他使用场景吗? 能给我介绍一下吗?<br>如果你听懂了,感觉面试官说的很有道理,可以说点赞美的话.</p>
<h3 id="[※※]objc中向一个nil对象发送消息将会发生什么？">[※※]objc中向一个nil对象发送消息将会发生什么？</h3><ol>
<li>在Objective-C中向nil发送消息是完全有效的——只是在运行时不会有任何作用:<ul>
<li>如果一个方法返回值是一个对象，那么发送给nil的消息将返回0(nil)。例如：Person * motherInlaw = [ aPerson spouse] mother];如果spouse对象为nil，那么发送给nil的消息mother也将返回nil。</li>
<li>如果方法返回值为指针类型，其指针大小为小于或者等于sizeof(void*)，float，double，long double 或者long long的整型标量，发送给nil的消息将返回0。</li>
<li>如果方法返回值为结构体,发送给nil的消息将返回0。结构体中各个字段的值将都是0。</li>
<li>如果方法的返回值不是上述提到的几种情况，那么发送给nil的消息的返回值将是未定义的。</li>
</ul>
</li>
</ol>
<h3 id="[※※※]objc中向一个对象发送消息[obj_foo]和objc_msgSend()函数之间有什么关系？">[※※※]objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？</h3><p>该方法编译之后就是objc_msgSend()函数调用.如果我没有记错的大概是这样的.<br>((void ()(id, SEL))(void )objc_msgSend)((id)obj, sel_registerName(“foo”));</p>
<h3 id="[※※※]什么时候会报unrecognized_selector的异常？">[※※※]什么时候会报unrecognized selector的异常？</h3><ul>
<li>当该对象上某个方法,而该对象上没有实现这个方法的时候</li>
</ul>
<h3 id="[※※※※]一个objc对象如何进行内存布局？（考虑有父类的情况）">[※※※※]一个objc对象如何进行内存布局？（考虑有父类的情况）</h3><ul>
<li>所有父类的成员变量和自己的成员变量都会存放在该对象所对应的存储空间中.</li>
<li>每一个对象内部都一个isA指针,指向他的类对象,类对象中存放着本对象的对象方法列表和成员变量的列表,属性列表,它内部也有一个isA指针指向元对象(meta class),元对象内部存放的是类方法列表,类对象内部还有一个superclass的指针,指向他的父类对象</li>
<li>根对象就是NSobject</li>
<li>如图:<br><img src="http://upload-images.jianshu.io/upload_images/321489-7e0c763ec5333106.png" alt="img"></li>
</ul>
<h3 id="[※※※※]一个objc对象的isa的指针指向什么？有什么作用？">[※※※※]一个objc对象的isa的指针指向什么？有什么作用？</h3><ul>
<li>指向他的类对象,从而可以找到对象上的方法</li>
</ul>
<h3 id="[※※※※]下面的代码输出什么？">[※※※※]下面的代码输出什么？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@implementation Son : Father</span><br><span class="line">- (id)init</span><br><span class="line">&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    <span class="keyword">if</span> (self) &#123;</span><br><span class="line">        NSLog(@<span class="string">"%@"</span>, NSStringFromClass([self class]));</span><br><span class="line">        NSLog(@<span class="string">"%@"</span>, NSStringFromClass([super class]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>输出的结果都是:Son,<br>原因:super 和 self 都是指向的本实例对象的,<br>不同的是,super调用的跳过本类方法,调用父类的方法<br>父类方法的class方法本来都是在基类中实现的,所以无论使用self和super调用都是一样的.</p>
<h3 id="[※※※※]runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）">[※※※※]runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）</h3><ul>
<li>每一个类对象中都一个方法列表,方法列表中记录着方法的名称,方法实现,以及参数类型,其实selector本质就是方法名称,通过这个方法名称就可以在方法列表中找到对应的方法实现.</li>
</ul>
<h3 id="[※※※※]使用runtime_Associate方法关联的对象，需要在主对象dealloc的时候释放么？">[※※※※]使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？</h3><ul>
<li>在ARC下不需要</li>
<li>在MRC中,对于使用retain或copy策略的需要</li>
</ul>
<h3 id="[※※※※※]objc中的类方法和实例方法有什么本质区别和联系？">[※※※※※]objc中的类方法和实例方法有什么本质区别和联系？</h3><ul>
<li>类方法<ul>
<li>类方法是属于类对象的</li>
<li>类方法只能通过类对象调用</li>
<li>类方法中的self是类对象</li>
<li>类方法可以调用其他的类方法</li>
<li>类方法中不能访问成员变量</li>
<li>类方法中不定直接调用对象方法</li>
</ul>
</li>
<li>实例方法<ul>
<li>实例方法是属于实例对象的</li>
<li>实例方法只能通过实例对象调用</li>
<li>实例方法中的self是实例对象</li>
<li>实例方法中可以访问成员变量</li>
<li>实例方法中直接调用实例方法</li>
<li>实例方法中也可以调用类方法(通过类名)</li>
</ul>
</li>
</ul>
<h3 id="[※※※※※]_objc_msgForward函数是做什么的，直接调用它将会发生什么？">[※※※※※]_objc_msgForward函数是做什么的，直接调用它将会发生什么？</h3><ol>
<li>没哟研究过,从名字来看是用来转发消息的,你能给我讲讲吗?谢谢!</li>
</ol>
<h3 id="[※※※※※]runtime如何实现weak变量的自动置nil？">[※※※※※]runtime如何实现weak变量的自动置nil？</h3><ol>
<li>没有研究过,你有研究过吗,可以给我讲讲吗?</li>
<li>我猜系统会维护一个弱指针列表,当某个对象销毁时候,它会把所有指向该对象的弱指针设置为nil</li>
</ol>
<h3 id="[※※※※※]能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？">[※※※※※]能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？</h3><ol>
<li>没有这么用过,运行中好像有添加属性方法. 你对这一块有很深了解吗,能给我讲讲吗.</li>
</ol>
<h3 id="[※※※]runloop和线程有什么关系？">[※※※]runloop和线程有什么关系？</h3><ol>
<li>每一个线程中都一个runloop,只有主线的的runloop默认是开启的,其他线程的runloop是默认没有开启的</li>
<li>可以通过CFRunLoopRun() 函数来开启一个事件循环</li>
<li>看SDWebImage源码的时候见到有这么用过.</li>
</ol>
<h3 id="[※※※]runloop的mode作用是什么？">[※※※]runloop的mode作用是什么？</h3><p>model 主要是用来指定时间在运行循环中的优先级的<br>苹果公开提供的 Mode 有两个：<br>kCFRunLoopDefaultMode<br>kCFRunLoopCommonModes</p>
<p>如果我们把一个NSTimer对象以kCFRunLoopDefaultMode添加到主运行循环中的时候,当一直有用户事件处理的时候,NSTimer将不再被调度<br>如果我们把一个NSTimer对象以kCFRunLoopCommonModes添加到主运行循环中的时候,当一直有用户事件处理的时候,NSTimer还能正常的调度,互不影响.</p>
<h3 id="[※※※※]以+_scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？">[※※※※]以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？</h3><p>同上</p>
<h3 id="[※※※※※]猜想runloop内部是如何实现的？">[※※※※※]猜想runloop内部是如何实现的？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 他是一个死循环</span><br><span class="line"><span class="number">2</span>.如果事件队列中存放在事件,那就取出事件,执行相关代码</span><br><span class="line"><span class="number">3</span>.如果没有事件,就挂起,等有事件了,立即唤醒事件循环,开始执行.</span><br></pre></td></tr></table></figure>
<h3 id="[※]objc使用什么机制管理对象内存？">[※]objc使用什么机制管理对象内存？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* MRC 手动引用计数</span><br><span class="line">* ARC 自动引用计数,现在通常使用自动引用计数</span><br></pre></td></tr></table></figure>
<h3 id="[※※※※]ARC通过什么方式帮助开发者管理内存？">[※※※※]ARC通过什么方式帮助开发者管理内存？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过编译器在编译的时候,插入如内管理的代码</span><br></pre></td></tr></table></figure>
<h3 id="[※※※※]不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）">[※※※※]不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在每次事件循环开始创建自动释放池,在每次事件结束销毁自动释放池</span><br><span class="line">以viewDidLoad方法为例,可以理解为在viewDidLoad方法开始执行之前创建自动释放池,</span><br><span class="line">在viewDidLoad方法执行之后销毁自动释放吃</span><br></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/321489-07bc9169c8d3b8cf.png" alt="imag"></p>
<h3 id="[※※※※]BAD_ACCESS在什么情况下出现？">[※※※※]BAD_ACCESS在什么情况下出现？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.  死循环了</span><br><span class="line"><span class="number">2</span>.  访问一个僵尸对象</span><br></pre></td></tr></table></figure>
<h3 id="[※※※※※]苹果是如何实现autoreleasepool的？">[※※※※※]苹果是如何实现autoreleasepool的？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 我猜想autoreleasepool 本质就是一个队列(数组),</span><br><span class="line"><span class="number">2</span>. 当调用autorelease的时候会把该对象添加到autoreleasepool中,并且把引用计数+<span class="number">1</span></span><br><span class="line"><span class="number">3</span>. 当autoreleasepool即将销毁的时候,把其中的所有对象进行一次release操作</span><br></pre></td></tr></table></figure>
<h3 id="[※※]使用block时什么情况会发生引用循环，如何解决？">[※※]使用block时什么情况会发生引用循环，如何解决？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">只要是一个对象对该block进行了强引用,在block内部有直接使用到该对象,</span><br></pre></td></tr></table></figure>
<h3 id="[※※]在block内如何修改block外部变量？">[※※]在block内如何修改block外部变量？</h3><ol>
<li>通过 __bock修改的外部变量,可以在block内部修改</li>
<li>想装B的话可以说一下__bock内部做了什么事</li>
</ol>
<h3 id="[※※※]使用系统的某些block_api（如UIView的block版本写动画时），是否也考虑引用循环问题？">[※※※]使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一般不用考虑,因为官方文档中没有告诉我们要注意发生强引用,所以推测系统控件一般没有对这些block进行强引用,所以我们可以不用考虑循环强引用的问题</span><br></pre></td></tr></table></figure>
<h3 id="[※※]GCD的队列（dispatch_queue_t）分哪两种类型？">[※※]GCD的队列（dispatch_queue_t）分哪两种类型？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">串行队列和并行队列</span><br></pre></td></tr></table></figure>
<h3 id="[※※※※]如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）">[※※※※]如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 创建异步队列</span><br><span class="line"><span class="number">2</span>. 创建dispatch_group  dispatch_group_t =  dispatch_group_create()</span><br><span class="line"><span class="number">3</span>. 通过组来执行异步下载任务</span><br><span class="line">  dispatch_group_async(queueGroup, aQueue, ^&#123;    </span><br><span class="line">        NSLog(@<span class="string">"下载图片."</span>);    </span><br><span class="line">  &#125;); </span><br><span class="line"><span class="number">4</span>.等到所有任务完成   dispatch_group_<span class="built_in">wait</span>(queueGroup, DISPATCH_TIME_FOREVER);</span><br><span class="line"><span class="number">5</span>.合成图片</span><br></pre></td></tr></table></figure>
<h3 id="[※※※※]dispatch_barrier_async的作用是什么？">[※※※※]dispatch_barrier_async的作用是什么？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">barrier:是障碍物的意思,在多个并行任务中间,他就像是一个隔离带,把前后的并行任务分开.</span><br><span class="line">dispatch_barrier_async 作用是在并行队列中，等待前面操作并行任务完成</span><br><span class="line">在执行dispatch_barrier_async中的任务</span><br><span class="line">如果后面还有并行任务,会开始执行后续的并行任务</span><br></pre></td></tr></table></figure>
<h3 id="[※※※※※]苹果为什么要废弃dispatch_get_current_queue？">[※※※※※]苹果为什么要废弃dispatch_get_current_queue？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">容易误用造成死锁</span><br></pre></td></tr></table></figure>
<h3 id="[※※※※※]以下代码运行结果如何？">[※※※※※]以下代码运行结果如何？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    NSLog(@<span class="string">"1"</span>);</span><br><span class="line">    dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@<span class="string">"2"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@<span class="string">"3"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只能输出1,然后线程主线程死锁</p>
<h3 id="[※※]addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？">[※※]addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">   // 添加键值观察</span><br><span class="line">    /**</span><br><span class="line">     <span class="number">1</span>. 调用对象：要监听的对象</span><br><span class="line">     <span class="number">2</span>. 参数</span><br><span class="line">     <span class="number">1</span>&gt; 观察者，负责处理监听事件的对象</span><br><span class="line">     <span class="number">2</span>&gt; 观察的属性</span><br><span class="line">     <span class="number">3</span>&gt; 观察的选项</span><br><span class="line">     <span class="number">4</span>&gt; 上下文</span><br><span class="line">     */</span><br><span class="line">    [self.person addObserver:self <span class="keyword">for</span>KeyPath:@<span class="string">"name"</span> options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:@<span class="string">"Person Name"</span>];</span><br><span class="line"></span><br><span class="line"> // NSObject 分类方法，意味着所有的 NSObject 都可以实现这个方法！</span><br><span class="line">// 跟协议的方法很像，分类方法又可以称为“隐式代理”！不提倡用，但是要知道概念！</span><br><span class="line">// 所有的 kvo 监听到事件，都会调用此方法</span><br><span class="line">/**</span><br><span class="line"> <span class="number">1</span>. 观察的属性</span><br><span class="line"> <span class="number">2</span>. 观察的对象</span><br><span class="line"> <span class="number">3</span>. change 属性变化字典（新／旧）</span><br><span class="line"> <span class="number">4</span>. 上下文，与监听的时候传递的一致</span><br><span class="line"></span><br><span class="line"> 可以利用上下文区分不同的监听！</span><br><span class="line"> */</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context &#123;</span><br><span class="line"></span><br><span class="line">    NSLog(@<span class="string">"睡会 %@"</span>, [NSThread currentThread]);</span><br><span class="line"></span><br><span class="line">    [NSThread sleepForTimeInterval:<span class="number">1.0</span>];</span><br><span class="line"></span><br><span class="line">    NSLog(@<span class="string">"%@ %@ %@ %@"</span>, keyPath, object, change, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="[※※※]如何手动触发一个value的KVO">[※※※]如何手动触发一个value的KVO</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给这个value设置一个值,就可以触发了</span><br></pre></td></tr></table></figure>
<h3 id="[※※※]若一个类有实例变量NSString_*_foo，调用setValue:forKey:时，可以以foo还是_foo作为key？">[※※※]若一个类有实例变量NSString *_foo，调用setValue:forKey:时，可以以foo还是_foo作为key？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">都可以</span><br></pre></td></tr></table></figure>
<h3 id="[※※※※]KVC的keyPath中的集合运算符如何使用？">[※※※※]KVC的keyPath中的集合运算符如何使用？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 必须用在集合对象上或普通对象的集合属性上</span><br><span class="line"><span class="number">2</span>. 简单集合运算符有@avg， @count ， @max ， @min ，@sum，</span><br><span class="line"><span class="number">3</span>. 格式  @<span class="string">"@sum.age"</span>或 @<span class="string">"集合属性.@max.age"</span></span><br></pre></td></tr></table></figure>
<h3 id="[※※※※]KVC和KVO的keyPath一定是属性么？">[※※※※]KVC和KVO的keyPath一定是属性么？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.一个可以是成员变量</span><br></pre></td></tr></table></figure>
<h3 id="[※※※※※]如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？">[※※※※※]如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？</h3><p><a href="http://www.cocoachina.com/ios/20150313/11321.html" target="_blank" rel="external">如何自己动手实现 KVO</a></p>
<h3 id="[※※※※※]apple用什么方式实现对一个对象的KVO？">[※※※※※]apple用什么方式实现对一个对象的KVO？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">同上</span><br></pre></td></tr></table></figure>
<h3 id="[※※]IBOutlet连出来的视图属性为什么可以被设置成weak?">[※※]IBOutlet连出来的视图属性为什么可以被设置成weak?</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为视图已经对它有一个强引用了</span><br></pre></td></tr></table></figure>
<h3 id="[※※※※※]IB中User_Defined_Runtime_Attributes如何使用？">[※※※※※]IB中User Defined Runtime Attributes如何使用？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User Defined Runtime Attributes 是一个不被看重但功能非常强大的的特性，</span><br><span class="line">它能够通过KVC的方式配置一些你在interface builder 中不能配置的属性。当你希望在IB中作尽可能多得事情，</span><br><span class="line">这个特性能够帮助你编写更加轻量级的viewcontroller</span><br></pre></td></tr></table></figure>
<h3 id="[※※※]如何调试BAD_ACCESS错误">[※※※]如何调试BAD_ACCESS错误</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.设置全局断点快速定位问题代码所在行</span><br></pre></td></tr></table></figure>
<h3 id="[※※※]lldb（gdb）常用的调试命令？">[※※※]lldb（gdb）常用的调试命令？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最常用就是 : po 对象</span><br></pre></td></tr></table></figure>
<p>其他的参照 <a href="http://www.cocoachina.com/ios/20150126/11021.html" target="_blank" rel="external">浅谈LLDB调试器</a></p>
<p>说明:此答案仅供参考,由于个人水平有限,会存在一些疏漏和表达不准确的地方,另外有些问题,我还没有答案.谁若有更准确的答案,欢迎给我留言,也可发送到的邮箱:583349285@qq.com,谢谢!</p>
<p>原文：<a href="http://www.jianshu.com/p/4fea8fa60d75?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note&amp;utm_source=weibo" target="_blank" rel="external">http://www.jianshu.com/p/4fea8fa60d75?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note&amp;utm_source=weibo</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试题/">面试题</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-easy-code" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/07/14/easy-code/" class="article-date">
  	<time datetime="2015-07-14T14:44:57.000Z" itemprop="datePublished">7月 14 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/14/easy-code/">漫画：如何编程？四步走，So easy！</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>编程很难吗？看完这张漫画，把四大秘籍记在心中，妈妈再也不担心了！哪里不会搜哪里！嘻嘻~</p>
<p><img src="http://ww3.sinaimg.cn/mw690/63918611gw1erb94ulw92j20bw06fglv.jpg" alt="此处输入图片的描述"></p>
<p>本文给大家推荐一张我们汉化的漫画。</p>
<p>英文漫画来自 Reddit。其实「程序员的那些事」主页君很早之前就收藏啦，后来忙其他事给忘了。周六翻译后交给小伙伴小伟做图了。</p>
<p>不多介绍了，大家直接往下看。</p>
<p><img src="http://ww2.sinaimg.cn/large/7cc829d3gw1esfpz0ycejj20m12eaais.jpg" alt="此处输入图片的描述"></p>
<p>原文网址：<a href="http://blog.jobbole.com/86184/" target="_blank" rel="external">http://blog.jobbole.com/86184/</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/code/">code</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/杂谈/">杂谈</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-swift-underline" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/20/swift-underline/" class="article-date">
  	<time datetime="2015-06-20T08:36:08.000Z" itemprop="datePublished">6月 20 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/20/swift-underline/">Swift中下划线和＂#＂的妙用</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>在Swift中，下划线和”#”有很多妙用，这里将已经看到的妙用进行总结，希望可以帮助更多学习Swift的朋友。1.格式化数字字面量。通过使用下划线可以提高数字字面量的可读性。</p>
<h2 id="1-格式化数字字面量">1.格式化数字字面量</h2><p>通过使用下划线可以提高数字字面量的可读性，例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> paddedDouble = <span class="number">123.000</span>_001   </span><br><span class="line"><span class="built_in">let</span> oneMillion = <span class="number">1</span>_000_000</span><br></pre></td></tr></table></figure></p>
<h2 id="2-忽略元组的元素值">2.忽略元组的元素值</h2><p>当我们使用元组时，如果有的元素不需要使用，这时可以使用下划线将相应的元素进行忽略，例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> http404Error = (<span class="number">404</span>, <span class="string">"Not Found"</span>)   </span><br><span class="line"><span class="built_in">let</span> (_, errorMessage) = http404Error</span><br></pre></td></tr></table></figure></p>
<p>代码中，只关心http404Error中第二个元素的值，所以第一个元素可以使用下划线进行忽略。</p>
<h2 id="3-忽略区间值">3.忽略区间值</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> base = <span class="number">3</span>   </span><br><span class="line"><span class="built_in">let</span> power = <span class="number">10</span>   </span><br><span class="line">var answer = <span class="number">1</span>   </span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">1</span>...power &#123;   </span><br><span class="line">    answer *= base   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有时候我们并不关心区间内每一项的值，可以使用下划线来忽略这些值。</p>
<h2 id="4-忽略外部参数名">4.忽略外部参数名</h2><p>(1)忽略方法的默认外部参数名<br>在使用方法（类方法或者实例方法）时，方法的第二个参数名及后续的参数名，默认既是内部参数名，又是外部参数名，如果不想提供外部参数名，可以在参数名前添加下划线来忽略外部参数名。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Counter &#123;   </span><br><span class="line">    var count: Int = <span class="number">0</span>   </span><br><span class="line">    func incrementBy(amount: Int, numberOfTimes: Int) &#123;   </span><br><span class="line">        count += amount * numberOfTimes   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上面的代码中，方法incrementBy()中的numberOfTimes具有默认的外部参数名：numberOfTimes，如果不想使用外部参数名可以使用下划线进行忽略，代码可以写为（不过为了提高代码的可读性，一般不进行忽略）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Counter &#123;   </span><br><span class="line">    var count: Int = <span class="number">0</span>   </span><br><span class="line">    func incrementBy(amount: Int, _ numberOfTimes: Int) &#123;   </span><br><span class="line">        count += amount * numberOfTimes   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(2)忽略具有默认值的参数的外部参数名<br>当函数（或者方法）的参数具有默认值时，Swift自动为该参数提供与参数名一致的默认外部参数名，因此在进行函数调用的时候，要提供默认参数名，可以使用下划线进行忽略默认外部参数名(但是不推荐忽略外部参数名，这主要是为了调用的时候可以方便地知道每个参数的含义)。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func join(s1: String, s2: String, joiner: String = <span class="string">" "</span>) -&gt; String &#123;   </span><br><span class="line">    <span class="built_in">return</span> s1 + joiner + s2   </span><br><span class="line">&#125;   </span><br><span class="line">// call the function.   </span><br><span class="line">join(<span class="string">"hello"</span>, <span class="string">"world"</span>, joiner: <span class="string">"-"</span>)</span><br></pre></td></tr></table></figure></p>
<p>如果不想使用默认外部参数名，可以进行如下修改：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func join(s1: String, s2: String, _ joiner: String = <span class="string">" "</span>) -&gt; String &#123;   </span><br><span class="line">    <span class="built_in">return</span> s1 + joiner + s2   </span><br><span class="line">&#125;   </span><br><span class="line">// call the function.   </span><br><span class="line">join(<span class="string">"hello"</span>, <span class="string">"world"</span>, <span class="string">"-"</span>)</span><br></pre></td></tr></table></figure></p>
<h1 id="在Swift中，”#”有一些妙用：">在Swift中，”#”有一些妙用：</h1><p>1.配置外部参数名<br>在函数（或者方法）的参数名前添加”#”，可以使该参数拥有相同的本地参数名和外部参数名。</p>
<p>注：在方法中，第二个及后续的参数，默认是具有和内部参数一致的外部参数名的，只有第一个参数没有，可以使用”#”符号来强制给第一个参数添加与本地参数名一致的外部参数名，但是不推荐。</p>
<p>(1)函数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func incrementBy(amount: Int, <span class="comment">#numberOfTimes: Int) &#123;   </span></span><br><span class="line">    count += amount * numberOfTimes   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>numberOfTimes的本地参数名（只能在函数内部使用）和外部参数名（在调用函数的时候作为标签使用）都是numberOfTimes。</p>
<p>(2)方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Counter &#123;   </span><br><span class="line">    var count: Int = <span class="number">0</span>   </span><br><span class="line">    func incrementBy(<span class="comment">#amount: Int, numberOfTimes: Int) &#123;   </span></span><br><span class="line">        count += amount * numberOfTimes   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>numberOfTimes默认具有本地参数名和外部参数名，amount没有外部参数名，使用”#”为amount强制指定外部参数名，在调用该方法的时候，必须使用外部参数名，否则会出现编译错误，提示缺少参数标签。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var counter = Counter()   </span><br><span class="line">counter.incrementBy(amount: <span class="number">4</span>, numberOfTimes: <span class="number">5</span>)   </span><br><span class="line">println(counter.count) // the result is <span class="number">20</span></span><br></pre></td></tr></table></figure></p>
<p>原文网址：<a href="http://www.cocoachina.com/industry/20140630/8982.html" target="_blank" rel="external">http://www.cocoachina.com/industry/20140630/8982.html</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Swift/">Swift</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-iOS-learn-link" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/05/31/iOS-learn-link/" class="article-date">
  	<time datetime="2015-05-31T13:34:49.000Z" itemprop="datePublished">5月 31 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/31/iOS-learn-link/">iOS usefull link</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<ol>
<li>Storyboards Tutorial<br><a href="http://www.raywenderlich.com/50308/storyboards-tutorial-in-ios-7-part-1" target="_blank" rel="external">Storyboards Tutorial in iOS 7: Part 1</a><br><a href="http://www.raywenderlich.com/50310/storyboards-tutorial-in-ios-7-part-2" target="_blank" rel="external">Storyboards Tutorial in iOS 7: Part 2</a></li>
<li>Core Data Tutorial<br><a href="http://www.raywenderlich.com/934/core-data-tutorial-for-ios-getting-started" target="_blank" rel="external">Core Data Tutorial for iOS: Getting Started</a><br><a href="http://www.raywenderlich.com/12170/core-data-tutorial-how-to-preloadimport-existing-data-updated" target="_blank" rel="external">Core Data on iOS 5 Tutorial: How To Preload and Import Existing Data</a><br><a href="http://www.raywenderlich.com/999/core-data-tutorial-for-ios-how-to-use-nsfetchedresultscontroller" target="_blank" rel="external">Core Data Tutorial for iOS: How To Use NSFetchedResultsController</a></li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-OC" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/05/29/OC/" class="article-date">
  	<time datetime="2015-05-29T10:28:22.000Z" itemprop="datePublished">5月 29 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/29/OC/">OC学习篇之---总结和学习目录</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>今天终于把OC的基础知识学习完了，但是这些知识只是最基础的，还有很多高级知识，这个可能需要后面慢慢的去学习才能体会到。下面就是这次学习OC的目录教程，如果大家发现有什么不正确的地方，请指正，小弟是新生，多请OC老鸟来喷~~</p>
<p>1、<a href="http://blog.csdn.net/jiangwei0910410003/article/details/41554591" target="_blank" rel="external">OC学习篇之—-概述</a></p>
<p>2、<a href="http://blog.csdn.net/jiangwei0910410003/article/details/41578003" target="_blank" rel="external">OC学习篇之—-第一个程序HelloWorld</a></p>
<p>3、<a href="http://blog.csdn.net/jiangwei0910410003/article/details/41657603" target="_blank" rel="external">OC学习篇之—-类的定义</a></p>
<p>4、<a href="http://blog.csdn.net/jiangwei0910410003/article/details/41683873" target="_blank" rel="external">OC学习篇之—-类的初始化方法和点语法的使用</a></p>
<p>5、<a href="http://blog.csdn.net/jiangwei0910410003/article/details/41707161" target="_blank" rel="external">OC学习篇之—-类的三大特性(封装，继承，多态)</a></p>
<p>6、<a href="http://blog.csdn.net/jiangwei0910410003/article/details/41774747" target="_blank" rel="external">OC学习篇之—-@class关键字的作用以及#include和#import的区别</a></p>
<p>7、<a href="http://blog.csdn.net/jiangwei0910410003/article/details/41775329" target="_blank" rel="external">OC学习篇之—-类目的概念和使用</a></p>
<p>8、<a href="http://blog.csdn.net/jiangwei0910410003/article/details/41775603" target="_blank" rel="external">OC学习篇之—-类的延展</a></p>
<p>9、<a href="http://blog.csdn.net/jiangwei0910410003/article/details/41776015" target="_blank" rel="external">OC学习篇之—-协议的概念和用法</a></p>
<p>10、<a href="http://blog.csdn.net/jiangwei0910410003/article/details/41777627" target="_blank" rel="external">OC学习篇之—-代理模式</a></p>
<p>11、<a href="http://blog.csdn.net/jiangwei0910410003/article/details/41788121" target="_blank" rel="external">OC学习篇之—-Foundation框架中的NSObject对象</a></p>
<p>12、<a href="http://blog.csdn.net/jiangwei0910410003/article/details/41788223" target="_blank" rel="external">OC学习篇之—-Foundation框架中的NSString对象和NSMutableString对象</a></p>
<p>13、<a href="http://blog.csdn.net/jiangwei0910410003/article/details/41809719" target="_blank" rel="external">OC学习篇之—-Foundation框架中的NSArray类和NSMutableArray类</a></p>
<p>14、<a href="http://blog.csdn.net/jiangwei0910410003/article/details/41830179" target="_blank" rel="external">OC学习篇之—-Foundation框架中的NSDirctionary类以及NSMutableDirctionary类</a></p>
<p>15、<a href="http://blog.csdn.net/jiangwei0910410003/article/details/41852835" target="_blank" rel="external">OC学习篇之—-Foundation框架中的其他类(NSNumber,NSDate,NSExcetion)</a></p>
<p>16、<a href="http://blog.csdn.net/jiangwei0910410003/article/details/41872551" target="_blank" rel="external">OC学习篇之—-归档和解挡</a></p>
<p>17、<a href="http://blog.csdn.net/jiangwei0910410003/article/details/41875015" target="_blank" rel="external">OC学习篇之—-文件的操作</a></p>
<p>18、<a href="http://blog.csdn.net/jiangwei0910410003/article/details/41912937" target="_blank" rel="external">OC学习篇之—-KVC和KVO操作</a></p>
<p>19、<a href="http://blog.csdn.net/jiangwei0910410003/article/details/41923401" target="_blank" rel="external">OC学习篇之—-通知(NSNotificationCenter)</a></p>
<p>20、<a href="http://blog.csdn.net/jiangwei0910410003/article/details/41923507" target="_blank" rel="external">OC学习篇之—-谓词(NSPredicate)</a></p>
<p>21、<a href="http://blog.csdn.net/jiangwei0910410003/article/details/41924683" target="_blank" rel="external">OC学习篇之—-内存管理介绍和使用</a></p>
<p>22、<a href="http://blog.csdn.net/jiangwei0910410003/article/details/41925967" target="_blank" rel="external">OC学习篇之—-@property和@synthesize的使用</a></p>
<p>23、<a href="http://blog.csdn.net/jiangwei0910410003/article/details/41926183" target="_blank" rel="external">OC学习篇之—-数组对象的引用计数问题和自动释放池的概念</a></p>
<p>24、<a href="http://blog.csdn.net/jiangwei0910410003/article/details/41926369" target="_blank" rel="external">OC学习篇之—-循环引用问题</a></p>
<p>25、<a href="http://blog.csdn.net/jiangwei0910410003/article/details/41926531" target="_blank" rel="external">OC学习篇之—-对象的拷贝</a></p>
<p>26、<a href="http://blog.csdn.net/jiangwei0910410003/article/details/41928053" target="_blank" rel="external">OC学习篇之—-单例模式</a></p>
<p>原文网址：<a href="http://blog.csdn.net/jiangwei0910410003/article/details/41928347" target="_blank" rel="external">http://blog.csdn.net/jiangwei0910410003/article/details/41928347</a><br>项目下载地址：<a href="http://download.csdn.net/detail/jiangwei0910410003/8259347" target="_blank" rel="external">http://download.csdn.net/detail/jiangwei0910410003/8259347</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Objective-C/">Objective-C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-iOS-framework" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/05/28/iOS-framework/" class="article-date">
  	<time datetime="2015-05-28T00:04:46.000Z" itemprop="datePublished">5月 28 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/28/iOS-framework/">iOS的主要框架介绍</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>本文是《Sunvey the Major Framworks》一文的翻译</p>
<p>框架是一个目录，这个目录包含了共享库，访问共享库里代码的头文件，和其它的图片和声音的资源文件。一个共享库定义的方法或函数可以被应用程序调用。</p>
<p>iOS提供了很多你可以在应用程序里调用的框架。要使用一个框架，需要将它添加到你的项目中，你的项目才可以使用它。许多应用程序都使用了如Foundation、UIKit、和Core Graphics这些框架。<br>根据你为应用程序选择的模版，相关的框架就已经被自动引入了。如果默认加入的框架不能满足你的应用程序的需求，你也可以加入需要的框架。</p>
<p>看看HelloWorld.xcodeproj项目里都包含了哪些框架（注：HelloWorld.xcodeproj是《Your First iOS App tutorial 》这篇教程里的一个项目）</p>
<blockquote>
<ol>
<li>在XCode里打开HelloWorld.xcodeproj项目（如果还没有打开）</li>
<li>在project navigator窗口里点击，点击Frameworks目录前面的三角形图标。你会看到：<br>UIKit.framework,Foundation.framework, 和CoreGraphics.framework</li>
<li>点击任意一个framework前面的三角，然后再点击Headers前面的三角，可以看到框架里的头文件。</li>
</ol>
</blockquote>
<p>每个框架对应IOS系统里的一层，每层建立在它下面层的上面。应该尽量使用上层的框架来代替下面的框架。更高层次的框架是对底层框架基于对象的抽象。<br><img src="http://my.csdn.net/uploads/201203/31/1333191260_7445.png" alt="IOS框架"></p>
<h1 id="iOS应用程序基于Foundation和UIKit框架">iOS应用程序基于Foundation和UIKit框架</h1><p>在你开发程序时，主要使用框架就是Foundation和UIKit，因为它们包含了你需要的大部分东西。</p>
<p>Foundation框架为所有的应用程序提供基本系统服务<br>你的应用程序，UIKit和其它的框架都是建立在Foundation框架上面的。Foundation框架是用Object-C对Core Foundation框架里许多特性的封装。</p>
<p>使用Foundation可以:</p>
<blockquote>
<ul>
<li>创建和管理集合，比如数组和字典</li>
<li>访问存储在应用程序里的图片和其它资源</li>
<li>创建和管理字符串</li>
<li>提交和接收通知</li>
<li>创建日期和时间对象</li>
<li>自动发现IP网络上的设备</li>
<li>操作URL流</li>
<li>执行异步代码</li>
</ul>
</blockquote>
<p>你已经在《Your First iOS App》里使用到了Foundation框架。比如，你使用一个NSString类的实例存储用户输入的userName。你还使用了Foundation框架的initWithFormat方法创建了一个字符串。</p>
<h2 id="UIKit框架提供创建基于触摸用户界面的类">UIKit框架提供创建基于触摸用户界面的类</h2><p>所有的iOS应用程序都基于UIKit，你不能是应用程序脱离这个框架。UIKit提供了在屏幕上绘制的机制，捕获事件，和创建通用用户界面元素。UIKit也通过管理显示在屏幕上的组件来组织复杂的项目。</p>
<p>使用UIKit可以：</p>
<blockquote>
<ul>
<li>构建和管理你的用户界面</li>
<li>捕获触摸和基于移动的事件</li>
<li>呈现文字和web内容</li>
<li>优化你的多任务程序</li>
<li>创建定制的用户界面元素</li>
</ul>
</blockquote>
<p>在《YouFirst iOS App Tutorial》里，你也使用到了UIKit。当你仔细查看程序是怎么运行起来的时候，你会看到UIApplicationMain函数创建一个UIApplication类的实例，这个实例会捕获进来的用户事件。你实现UITextFieldDelegate协议，然后在用户按下Done时隐藏键盘。实际上，你是在使用UIKit创建用户界面上的UITextField， UILabel，和UIButton类。</p>
<h1 id="你需要知道的其它重要的框架">你需要知道的其它重要的框架</h1><p>Core Data , Core Graphics, Core Animation,和OpenGLES框架都是高级的技术。所以这些框架对于你开发应用程序也是很重要的，它们都需要时间去学习和掌握。</p>
<h2 id="Core_Data框架管着理应用程序数据模型">Core Data框架管着理应用程序数据模型</h2><p>Core Data提供对象的管理，使用Core Data，你可以创建模型对象，并管理这些对象。你管理这这些对象间的联系并修改数据。Core Data提供的内建SQLlite技术可以高效的管理数据。</p>
<p>使用Core Data可以：</p>
<blockquote>
<ul>
<li>在库里存储和接收对象</li>
<li>提供基本的undo/redo</li>
<li>自动验证属性值</li>
<li>过滤、分组和优化内存中的数据</li>
<li>用[NSFetchedResultsController]管理表视图中的结果</li>
<li>支持基于文档的应用程序<h2 id="Core_Graphics框架帮助你创建图形">Core Graphics框架帮助你创建图形</h2>高质量的图形对于所有的iOS应用程序都是很重要的。在iOS中最简单且最快捷的创建图形的方式是使用UIKit框架提供的基于预渲染图形的视图和控件，然后让UIKit和iOS完成绘制。但是当你需要创建复杂的图形时，Core Graphics则提供了更底层的库来帮助你。</li>
</ul>
</blockquote>
<p>使用Core Graphics可以：</p>
<blockquote>
<ul>
<li>创建基于路径的绘图</li>
<li>抗锯齿渲染</li>
<li>添加梯度、图片和颜色</li>
<li>Use coordinate-space transformations.</li>
<li>创建、显示和分析PDF文档<h2 id="Core_Animation允许你创建高级的动画和虚拟效果">Core Animation允许你创建高级的动画和虚拟效果</h2>UIKit提供建立在Core Animation之上的动画。如果你需要比UIKit能力更高级的功能，可以直接使用Core Animation。Core Animation接口包含在Quartz Core框架里。使用Core Animation可以创建嵌套的对象，并且可以对它们操作、旋转、缩放和转换。使用Core animation，你可以创建动态的用户界面而不用使用更底层的图形API，如OpenGL ES。</li>
</ul>
</blockquote>
<p>使用Core Animation可以：</p>
<blockquote>
<ul>
<li>创建定制动画</li>
<li>添加定时函数和图形</li>
<li>支持帧动画</li>
<li>Specify graphical layout constraints.</li>
<li>Group multiple-layer changes into anatomic update.</li>
</ul>
</blockquote>
<h2 id="OpenGL_ES_框架提供2D和3D绘图工具">OpenGL ES 框架提供2D和3D绘图工具</h2><p>OpenGL ES支持2D和3D绘图，Apple的OpenGL ES实现通过硬件提供了高速的全屏游戏式的应用程序。</p>
<p>使用OpenGL ES可以：</p>
<blockquote>
<ul>
<li>创建2D和3D图形</li>
<li>创建更复杂的图形，比如数据虚拟化、模拟飞行，或者视频游戏</li>
<li>访问底层图形设备</li>
</ul>
</blockquote>
<h1 id="根据需要向项目中添加其它框架">根据需要向项目中添加其它框架</h1><p>还有许多框架可以添加到你的程序里。当你决定使用一个框架但项目里却没有引入这个框架时，你就需要将它加入到你的项目里。<br><img src="http://my.csdn.net/uploads/201203/31/1333191310_2042.png" alt="此处输入图片的描述"></p>
<p>将别的框架添加到工程里</p>
<pre><code><span class="number">1</span> 打开工程

<span class="number">2</span> 点击项目名，显示project editor

<span class="number">3</span> 在TARGETS列表中选中要添加框架的工程

<span class="number">4</span> 点击project editor顶部的<span class="keyword">Build </span>Phases

<span class="number">5</span> 点击Link <span class="keyword">Binary </span>With Libraries前面的三角形打开这个分组

<span class="number">6</span> 通过点击添加(+)来添加一个框架

<span class="number">7</span> 在列表中选择一个框架，然后点击<span class="keyword">Add按钮</span>
</code></pre><p>原文地址： <a href="http://blog.csdn.net/ahopedog/article/details/7416837" target="_blank" rel="external">http://blog.csdn.net/ahopedog/article/details/7416837</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Framework/">Framework</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-motto" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/05/27/motto/" class="article-date">
  	<time datetime="2015-05-27T14:08:12.000Z" itemprop="datePublished">5月 27 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/27/motto/">格言</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="【归零】">【归零】</h2><blockquote>
<p>人生需要“归零”。每过一段时间，都要将过去“清零”，让自己重新开始。不要让过去成为现在的包袱，轻装上阵才能走得更远。<br>人的心灵就像一个容器，时间长了里面难免会有沉渣。时时清空心灵的沉渣，该放手时就放手，该忘记的要忘记。<br>扔掉过去的包袱，时时刷新自己，这样必能收获满意的人生。 </p>
</blockquote>
<h2 id="【一个有效的管理者应有的五个习惯】">【一个有效的管理者应有的五个习惯】</h2><blockquote>
<ol>
<li>知道如何利用自己的时间；</li>
<li>注意使自己的努力产生必要的成果，而不是工作本身，重视对外界的贡献；</li>
<li>把工作建立在优势上,他们自己的优势，善于利用自己的长处，上级、同事和下级的长处；</li>
<li>精力集中于主要领域；</li>
<li>善于做出有效的决策。</li>
</ol>
</blockquote>
<h2 id="【面对职场迷茫期的三条对策】">【面对职场迷茫期的三条对策】</h2><blockquote>
<ol>
<li>下策：抱怨。抱怨企业，抱怨上司，抱怨客户，抱怨同事，抱怨自己等。因为缺乏责任感，奋斗精神较差。</li>
<li>中策：忍耐。忍耐，精神有些紧张。责任感、奋斗精神不足。</li>
<li>上策：寻求现有岗位价值最大化。想办法先达到优秀。 </li>
</ol>
</blockquote>
<h2 id="【销售员、销售经理和销售总监的区别】">【销售员、销售经理和销售总监的区别】</h2><blockquote>
<p>销售员：知道今天要干什么，最多知道下几个月要干什么；销售经理：知道这个月要干什么，最多知道今年要干什么；<br>销售总监知道今年要干什么，最多知道明年后年要干什么。对未来知道的越多，就会为未来提前做好更多准备。<br>合作一代，开发一代，储备一代，这就是销售!</p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/随笔/">随笔</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-OC-foundation" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/05/27/OC-foundation/" class="article-date">
  	<time datetime="2015-05-27T09:15:30.000Z" itemprop="datePublished">5月 27 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/27/OC-foundation/">iOS7中Objective-C和Foundation的新特性</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>注意事项（Ray）：文章来自iOS 7 by Tutorials  iOS 7Feast的一部分（略）</p>
<p><strong>Objective-C</strong> 是最重要的iOS和OSX apps的开发工具。你可以使用其他语言的第三方框架开发apps，例如HTML&amp;Javascript或者C#，但是如果你很快的写出一个超炫的高效率的原声apps你就需要使Objective-C。</p>
<p><strong>Foundation</strong> 是你开发Objective-C应用时用到的核心框架之一。</p>
<p>作为一名iOS开发者，非常有必要了解最新的Objective-C和Foundation的特性，在iOS7中有了一些重要的改变需要你了解。</p>
<p>在这篇文章中，你将快速浏览一些在Objective-C和Foundation中新的功能。</p>
<h2 id="1-Modules（模块）">1.Modules（模块）</h2><p>机会是好的，你已经写了一千遍或更多＃import语句：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#import    </span></span><br><span class="line"><span class="comment">#import    </span></span><br><span class="line"><span class="comment">#import</span></span><br></pre></td></tr></table></figure></p>
<p>这个语法要追溯到Objective-C的根：vanilla C。#import语句是预处理器指令和#include有类似的方式工作。唯一的区别是#import不会导入已经导入的头文件；它是一次性处理。</p>
<p>当预处理遇到一个#import命令时，就会按字面的意思用被导入的头文件的全部内容替换那一行。预编译会递归的这么处理，即使可能是大量的头文件。</p>
<p>UIKit的头文件，UIKit.h，包含了UIKit框架中包含的所有其他头文件。这意味着，您不必手动导入每个框架的头文件，例如UIViewController.h，UIView.h UIButton.h的。</p>
<p>对UIKit框架的大小感到好奇嘛？通过计算所有行的全部UIKit中的头，你会发现它相当于超过11,000行代码！</p>
<p>在一个标准的iOS应用，你会在您的大部分文件中导入的UIKit，这意味着每一个文件最终被长11000行。这是不够理想的，更多的代码意味着更长的编译时间。</p>
<h3 id="1-1_原始解决方案：预编译头文件（Original_solution:_Pre-compiled_Headers）">1.1 原始解决方案：预编译头文件（Original solution: Pre-compiled Headers）</h3><p>预编译的头文件，或PCH文件，试图解决这个问题，通过提供在编译的预处理阶段预先计算和缓存需要的代码。你可能看过Xcode生成的stock PCH 文件，像下面这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#import    </span></span><br><span class="line"><span class="comment">#ifndef __IPHONE_5_0   </span></span><br><span class="line"><span class="comment">#warning "This project uses features only available in iOS SDK 5.0 and later."   </span></span><br><span class="line"><span class="comment">#endif   </span></span><br><span class="line">   </span><br><span class="line"><span class="comment">#ifdef __OBJC__   </span></span><br><span class="line">    <span class="comment">#import    </span></span><br><span class="line">    <span class="comment">#import    </span></span><br><span class="line"><span class="comment">#endif</span></span><br></pre></td></tr></table></figure></p>
<p>如果开发人员开发的app的targets是iOS5之前的一个SDK,#warning将通知他们。UIKit和Foundation umbrella 头文件是stockPCH的一部分。因为在您的应用程序里的每一个文件将使用Foundation并且大部分会使用UIKit。因此这些都是很好的添加对于PCH文件以便于在你的APP中预先计算和缓存这些文件的编译文件。</p>
<p>你可能会问“这有什么问题嘛？”PCH没有任何技术性的问题就像是——if it isn’t broke, don’tfix it（没有坏，就不要修）。然而你可能错失了很多性能优势，由于一个易维护的、高度优化的PCH文件导致（你可能会错过了一台主机上的维护良好的，高度优化的PCH文件的性能优势）。例如你可能在好几个地方用到Map Kit框架，你就会看到了通过添加Map Kit umbrella头文件或者单独的你用到的Map Kit类头文件到PCH文件中对编译时间的提升。</p>
<p>我们都是lazy developers ，没有人有时间去维护我们工作的项目的PCH文件。那就是为什么modules被开发为LLVM的特性。</p>
<p><span style="color:red">注意事项：LLVM是一个模块化和可重复使用的编译器和工具技术与Xcode捆绑的集合。 LLVM有几个组成部分：对oc开发者最重要的是clang，原生的C、C++和Objective-C编译器；和LLDB，原生debugger—开发者最好的朋友。</span></p>
<h3 id="1-2_新的解决方案：模块_（Modules）">1.2 新的解决方案：模块 （Modules）</h3><p>Modules第一次在Objective-C中公共露面是在2012 LLVM开发者大会上Apple’s Doug Gregor的一次谈话。这是一次迷人的谈话，强烈推荐给对编译感兴趣的人。你可以在线看这些视频：<a href="http://llvm.org/devmtg/2012-11/#talk6。" target="_blank" rel="external">http://llvm.org/devmtg/2012-11/#talk6。</a></p>
<p>Modules封装框架比以往任何时候更加清洁。不再需要预处理逐行地用文件所有内容替换#import指令。相反，一个模块包含了一个框架到自包含的块中，就像PCH文件预编译的方式一样提升了编译速度。并且你不需要在PCH文件中声明你要用到哪些框架，使用Modules简单的获得了速度上的提升。</p>
<p>但是Modules不只有这些，我相信你会想起这些步骤当你第一次在一个app使用一个新的框架的时候，就像下面这样：<br>(1).在使用框架的文件中添加#import<br>(2).用的框架写代码<br>(3).编译<br>(4).查看链接错误<br>(5).想起忘记链接的框架<br>(6).添加忘记的框架到项目中<br>(7).重新编译</p>
<p>忘记链接框架式是一件经常的犯的错误，但是Modules解决的非常好。</p>
<p>一个Modules不仅告诉编译器哪些头文件组成了Modules，而且还告诉编译器什么需要链接。这个就解救了你不用你去手动的链接框架。这虽然是一件小事，但是能让开发更加简单就是一件好事。</p>
<h3 id="1-3_怎样使用Modules">1.3 怎样使用Modules</h3><p>Modules的使用相当简单。对于存在的工程，第一件事情就是使这个功能生效。你可以在项目的Build Settings通过搜索Modules找到这个选项，改变Enable Modules 选项为YES，像这样：</p>
<p>所有的新工程都是默认开启这个功能的，但是你应该在你所有存在的工程内都开启这个功能。</p>
<p>Link Frameworks Automatically选项可以用来开启或者关闭自动连接框架的功能，就像描述的那么简单。还是有一点原因的为什么你会想要关闭这个功能。</p>
<p>一旦Modules功能开启，你就可以在你的代码中使用它了。像这样做，对以前用到的语法有一点小小的改动。用@import代替#import：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@import UIKit;   </span><br><span class="line">@import MapKit;   </span><br><span class="line">@import iAd;</span><br></pre></td></tr></table></figure></p>
<p>只导入一个框架中你需要的部分也是可能的。例如你只想要导入UIView，你就这样写：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import UIKit.UIView;</span><br></pre></td></tr></table></figure></p>
<p>对的-他真的是这么简单，技术上，你不需要把所有的#import都换成@import，因为编译器会隐式的转换他们。然而尽可能的用新的语法还是好的习惯。</p>
<p>在你兴奋的要开始使用Modules之前，不幸的是有一个小警告。Xcode5的Modules还不支持你自己的或者第三方的框架。这是一个不幸的缺点，没有事情是完美的，即使是Objective-C！</p>
<h2 id="2-新的返回类型-instancetype">2.新的返回类型-instancetype</h2><p>Objective-C添加了一个新的返回类型，名字叫instancetype。这个仅仅被用作Objective-C方法的返回类型和对编译器的一个暗示，暗示方法的返回类型将是这个方法属于的类的实例。</p>
<p>注意事项： 这个特征在iOS7和Xcode上没有严格，但是随着时间的推移会被悄悄的加进最近的Clang。然而Xcode5第一次声明苹果已经在他们的框架中使用了这个。你可以再官方的Clang网页看到更多的内容：<a href="http://clang.llvm.org/docs/LanguageExtensions.html#objective-c-features" target="_blank" rel="external">http://clang.llvm.org/docs/LanguageExtensions.html#objective-c-features</a></p>
<p>为什么要使用instancetype呢？看看下面的代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary *d = [NSArray arrayWithObjects:@(<span class="number">1</span>), @(<span class="number">2</span>), nil];   </span><br><span class="line">NSLog(@<span class="string">"%i"</span>, d.count);</span><br></pre></td></tr></table></figure></p>
<p>虽然这个明显是不正确的，但是编译器却不会提醒你任何错误。自己尝试一下在Xcode4.6下编译。你将看到没有任何警告，但是这段代码明显是错误的。这段代码甚至能够没有异常的跑起来，因为NSDictory和NSArray的实例都能相应count。</p>
<p>这段代码正常的原因是由于Objective-C的强大的动态特性。这个类型是对编译器的一个指导。Count方法在运行的时候被查找无论什么类，正好dictionary变量有这个方法。在这种情况下，count方法存在，编译器相信他是正确的。然而稍后你用到了NSDictionary有而NSArray没有的方法例如objectAtIndex：就会出现问题。首先他不会明确指出问题出现在哪里。</p>
<p>但是问什么编译器没有指出 +[NSArray arrayWithObjects:]方法返回的实例不是NSDictionary实例呢？那是因为这个方法声明如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (id)arrayWithObjects:(id)firstObj, ...;</span><br></pre></td></tr></table></figure></p>
<p>注意到返回类型是id。id类型是一个意味着任何Objective-C类的umbrella类型。他甚至都不是NSObject的子类。方法没有返回类型信息而不是返回Objective-C类的实例。这样做是有用的，当你隐式的转换id到一个确切的类型时编译器不会警告你。例如上面的NSDictionary例子。如果产生警告，id就没有用啦。</p>
<p>但是这个方法的返回类型为什么是id呢？你可以子类化这个方法然后仍然没有问题的使用它。为了证明为什么,考虑下面的NSArray的子类：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@interface MyArray : NSArray   </span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>现在考虑下你的子类在下面的代码的使用：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyArray *array = [MyArray arrayWithObjects:@(<span class="number">1</span>), @(<span class="number">2</span>), nil];</span><br></pre></td></tr></table></figure></p>
<p>现在你应该知道为什么arrayWithObjects:返回类型必须是id。如果是NSArray*，这个子类需要转化成必要的类。这就是新的instancetype返回类型用到的地方。如果你看iOS7SDK中NSArray的头文件，你将注意到这个方法变成了下面的样子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)arrayWithObjects:(id)firstObj, ...;</span><br></pre></td></tr></table></figure></p>
<p>唯一的不同就是返回类型。新的返回类型提示编译器返回类型是方法被调用的类的实例。所以当arrayWithObjects:被调用的是NSArray时，返回类型是NSArray<em>。当调用的是MyArray时，返回类型是MyArray</em>。</p>
<p>当维护成功子类化的能力的时候，用id就会出现的问题。如果用Xcode5编译原始的代码，你会看到下面的警告：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">warning: incompatible pointer types initializing <span class="string">'NSDictionary *'</span> with an expression of <span class="built_in">type</span> <span class="string">'NSArray *'</span> [-Wincompatible-pointer-types]   </span><br><span class="line">NSDictionary *d = [NSArray arrayWithObjects:@(<span class="number">1</span>), @(<span class="number">2</span>), nil];</span><br></pre></td></tr></table></figure></p>
<p>那是有帮助的，现在你有机会修改这个问题以防止接下来crash。</p>
<p>初始化方法是候选要使用这个新的返回类型的。现在如果你设置初始化方法返回一个不完整的类型编译器已经提醒你了。但是他可能隐式的转化id到instancetype。你应该仍然使用instancetype，因为明确一点还是比较好的。</p>
<p>尽可能多的使用instancetype，他会成为Apple的标准-你不会知道这个将减少你多少你将来的degugging的痛苦时间。</p>
<h2 id="3-新的_Foundations">3.新的 Foundations</h2><p>接下来就是Objective-C核心开发框架Foundation的一些新东西。没有Foundation很难开发Objective-C应用，所有的iOS Apps都需要使用。在新的iOS SDK中看看这些新添加的内容。</p>
<p>Foundation最主要的提升是网络。(说的应该是NSURLSession)在iOS 7 by Tutorials 有一整章描述。（略）</p>
<p>文章剩下部分展示了Foundation新增加的和改变的东西。</p>
<h3 id="3-1_NSArray">3.1 NSArray</h3><p>尝试在NSArray实例中访问一个Object,如果下表越界将爆出异常。当你用数组当做队列的时候，你可能经常要访问数组中第一个或者最后一个元素。 在先进先出队列（FIFO）你可能要从数组的前端POP元素，如果是先进后出队列（FILO）就要从数组末尾POP元素。</p>
<p>然而，当你访问数组的第一个或者最后一个元素的时候，你一定要确定没有超出数组的边界，如果数组是空得话经常发生这样的访问。这就会导致在调用objectAtIndex:不报错而产生冗余的代码，就像下面的这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *queue = [NSMutableArray new];   </span><br><span class="line">// ...   </span><br><span class="line"><span class="keyword">if</span> (queue.count &gt; <span class="number">0</span>) &#123;   </span><br><span class="line">    id firstObject = [queue objectAtIndex:<span class="number">0</span>];   </span><br><span class="line">    // Use firstObject   </span><br><span class="line">&#125;   </span><br><span class="line">// ...   </span><br><span class="line"><span class="keyword">if</span> (queue.count &gt; <span class="number">0</span>) &#123;   </span><br><span class="line">    id lastObject = [queue objectAtIndex:(queue.count - <span class="number">1</span>)];   </span><br><span class="line">    // Use lastObject   </span><br><span class="line">&#125;   </span><br><span class="line">``` </span><br><span class="line">要访问最后一个元素，你应该会用到NSArray的这个方法：</span><br><span class="line">```Bash</span><br><span class="line">- (id)lastObject;</span><br></pre></td></tr></table></figure></p>
<p>Objective-C开发者应该可以高兴了，现在他们有了一个方法来访问数组的第一个元素：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)firstObject;</span><br></pre></td></tr></table></figure></p>
<p>简单的方法总是被证明是有用的。你不在需要检查数组是不是空的啦。你可能曾经遇到过由于越界产生的Crash。你可以看看下面的注意事项：</p>
<p><span style="color:red">注意事项：如果你仔细的看NSArray头文件，其实firstObject在iOS4.0就已经出现啦，直到iOS7才对外开放。因此你可以在iOS7之前获取这个方法，但是你必须在你自己的头文件里声明这个方法firstObject来告诉编译器它确实存在。这不是一个提倡的方法，好歹Apple把这个方法公开了。</span></p>
<p>先前的代码可以用这两个方法重写，就不用检查数组长度了，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *queue = [NSMutableArray new];   </span><br><span class="line">// ...   </span><br><span class="line">id firstObject = [queue firstObject];   </span><br><span class="line">// Use firstObject   </span><br><span class="line">id lastObject = [queue lastObject];   </span><br><span class="line">// Use lastObject</span><br></pre></td></tr></table></figure></p>
<h2 id="3-2_NSData">3.2 NSData</h2><p>Data是你编程处理最多的事情。NSData是Foundation类，封装了原始字节并提供方法操纵这些字节，可以从一个文件读或者写数据。但是一个简单的任务Base64编码和解码还没有原生的实现。直到iOS7才出现。</p>
<p>Base64是一组二进制到文本转换的方案，以ASCII格式提供二进制数据。这些方案用来编码二进制数据以存储或者通过把多媒体文件转换成文本数据进行传输。这个能保证数据在传输过程中的完整性。Base64编码的最常见的用途是处理电子邮件附件，或者编码小图片，这些小图片是通过基于Web的API返回的JSON相应的一部分。</p>
<p>在iOS7之前，Base64的 编码和解码是需要自己实现的或者使用第三方库。典型的Apple风格，现在是非常容易的使用这个功能。有四个Base64方法如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (id)initWithBase64EncodedString:(NSString *)base64String    </span><br><span class="line">      options:(NSDataBase64DecodingOptions)options;   </span><br><span class="line">   </span><br><span class="line">- (NSString *)base64EncodedStringWithOptions:   </span><br><span class="line">      (NSDataBase64EncodingOptions)options;   </span><br><span class="line">    </span><br><span class="line">- (id)initWithBase64EncodedData:(NSData *)base64Data    </span><br><span class="line">      options:(NSDataBase64DecodingOptions)options;   </span><br><span class="line">    </span><br><span class="line">- (NSData *)base64EncodedDataWithOptions:   </span><br><span class="line">      (NSDataBase64EncodingOptions)options;</span><br></pre></td></tr></table></figure></p>
<p>头两个方法是处理字符串的，后两个方法是处理UTF-8编码数据的。这两个成对的方法功能是一样的，但是有时候用其中一个比另一个效率要高。如果你想要Base64编码字符串然后写进文件，你应该使用UTF-8编码数据的这对方法。另一方面，如果你打算Base64编码字符串然后用做JSON，你应该使用另外一对方法。如果你曾经实现过Base64编码方法，现在可以删除了，因为Apple已经帮你实现了。</p>
<h2 id="3-3_NSTimer">3.3 NSTimer</h2><p>NSTimers在apps中经常用来执行周期性任务。NSTimer虽然很有用但是也会产生问题。当有几个定时器在用的时候，他们可能间断性的触发。这就是意味着CPU是间断性处于活动状态的。这样做是更加有效率的，当CPU换起的时候执行一些任务，然后进入睡眠状态。为了解决这个问题，Apple给NSTimer添加了一个容忍属性来适应这种行为。</p>
<p>容忍提供系统一个指导在timer在计划之后允许延迟多长时间。为了减少CPU负荷底层系统将要集合这些活动。新属性的方法是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (NSTimeInterval)tolerance;   </span><br><span class="line">- (void)<span class="built_in">set</span>Tolerance:(NSTimeInterval)tolerance;</span><br></pre></td></tr></table></figure></p>
<p>你可能永远都不需要用到这个属性，但是当你在非常密切相近的触发了几个定时器，你可能发现他是有用的，当你在用Instruments检测CPU使用率的时候。</p>
<h2 id="3-3_NSProgress">3.3 NSProgress</h2><p>不经常见到Foundation会完整的添加一个新类。他是一个稳定的框架。主要是因为不经常用到核心的类。然而iOS7提供了一个完整的新类NSProgress。</p>
<p>本质上，NSProgress是用来通过Objective-C代码产生进度报告的，分离每一个独立模块的进度。例如，你可以在一些数据上执行几个不同的任务，然后每个任务可以管理他自己的进度然后报告给他的父任务。</p>
<h3 id="3-3-1NSProgress结构">3.3.1NSProgress结构</h3><p>NSProgress最简单的使用方法是报告一些任务集合的进度。例如，你有10个任务执行，当每个任务完成的时候你可以报告进度。当有一个任务完成的时候进度增加%10。然后在NSProgress的实例上使用Key Value Observing（KVO），你能够了解到这个实例的进度。你可以使用这个通知来更新进度条或者显示一个指示文字。</p>
<p>NSProgress有更多的用途。Apple通过这个父子类的关系结构使他更加强大。NSProgress的结构更像是网状树。每一个NSProgress有一个父类和多个子类。每一个实例有一个执行的工作单元的总数，当前任务会处理完成的子任务数的更新来反馈当前状态。这么做的话，父类也会被通知进度。</p>
<p>为了减少NSProgress实例的传递，每个线程有自己的NSProgress实例然后子实例可以直接从这个实例创建。没有这个功能，每个想要报告进度的任务不得不通过参数的方式来通知。</p>
<h3 id="3-3-2报告进度">3.3.2报告进度</h3><p>NSProgress使用非常简单。以下面的方法开始：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+(NSProgress *)progressWithTotalUnitCount:(int64_t)unitCount;</span><br></pre></td></tr></table></figure></p>
<p>这个方法创建了一个NSProgress实例作为当前实例的子类，以要执行的任务单元总数来初始化。例如，如果任务是循环一个数组，然后你可能用数组数来初始化NSProgress实例。例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NSArray*array = /* ... */;   </span><br><span class="line">    </span><br><span class="line">NSProgress*progress =   </span><br><span class="line">    [NSProgressprogressWithTotalUnitCount:array.count];   </span><br><span class="line">    </span><br><span class="line">[arrayenumerateObjectsUsingBlock:   </span><br><span class="line">    ^(id obj, NSUInteger idx, BOOL *stop) &#123;   </span><br><span class="line">        // Perform an expensive operation onobj   </span><br><span class="line">        progress.completedUnitCount = idx;   </span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure></p>
<p>随着迭代的进行，上面的代码会更新NSProgress实例来反映当前进度。</p>
<h3 id="3-3-3接收进度更新">3.3.3接收进度更新</h3><p>你可以通过下面的属性在任何时候获取任务进度：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property(<span class="built_in">readonly</span>) double fractionCompleted;</span><br></pre></td></tr></table></figure></p>
<p>返回值是0到1，显示了任务的整体进度。当没有子实例的话，fractionCompleted就是简单的完成任务数除以总得任务数。</p>
<p>Key Value Observing（KVO）是最好的方法来获取fractionCompleted值得变化。这么做非常简单。你只需要做的是添加一个NSProgress的fractionCompleted属性的观察者。像下面这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[_progressaddObserver:self   </span><br><span class="line">           <span class="keyword">for</span>KeyPath:@<span class="string">"fractionCompleted"</span>   </span><br><span class="line">              options:NSKeyValueObservingOptionNew   </span><br><span class="line">               context:NULL];</span><br></pre></td></tr></table></figure></p>
<p> 然后覆盖KVO的这个方法来获取改变:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-(void)observeValueForKeyPath:(NSString *)keyPath   </span><br><span class="line">                      ofObject:(id)object   </span><br><span class="line">                        change:(NSDictionary*)change   </span><br><span class="line">                       context:(void *)context   </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">if</span> (object == _progress) &#123;   </span><br><span class="line">        // Handle new fractionCompleted value   </span><br><span class="line">        <span class="built_in">return</span>;   </span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    // Always call super, incase it uses KVOalso   </span><br><span class="line">    [super observeValueForKeyPath:keyPath   </span><br><span class="line">                         ofObject:object   </span><br><span class="line">                           change:change   </span><br><span class="line">                          context:context];   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个方法中你可以获取fractionCompleted的值的改变。例如你可能改变进度条或者提示文字。</p>
<p>当然，当你处理完的时候记得注销KVO是很重要的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[_progressremoveObserver:self   </span><br><span class="line">              <span class="keyword">for</span>KeyPath:@<span class="string">"fractionCompleted"</span>   </span><br><span class="line">                  context:NULL];</span><br></pre></td></tr></table></figure></p>
<p>你必须总是要注销的，如果你没有注销，当被注册的Object释放的时候就会Crash。所以如果必要的话在dealloc中注销作为最后的保障。</p>
<h2 id="4-WhereTo_Go_From_Here（以后该怎么办）">4.WhereTo Go From Here（以后该怎么办）</h2><pre><code><span class="list">(<span class="keyword">略）</span></span>
</code></pre><h2 id="5-原文链接和参考链接">5.原文链接和参考链接</h2><p>原文链接：<a href="http://www.raywenderlich.com/49850/whats-new-in-objective-c-and-foundation-in-ios-7" target="_blank" rel="external">http://www.raywenderlich.com/49850/whats-new-in-objective-c-and-foundation-in-ios-7</a><br><a href="http://www.cocoachina.com/ios/20140508/8356.html" target="_blank" rel="external">http://www.cocoachina.com/ios/20140508/8356.html</a><br>参考链接：<br><a href="http://www.onevcat.com/2013/06/new-in-xcode5-and-objc/" target="_blank" rel="external">http://www.onevcat.com/2013/06/new-in-xcode5-and-objc/</a><br><a href="http://www.longyiqi.com/blog/programming-languages/2012/04/05/at-import-objc/" target="_blank" rel="external">http://www.longyiqi.com/blog/programming-languages/2012/04/05/at-import-objc/</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Foundation/">Foundation</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Objective-C/">Objective-C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-hexo-not-found" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/05/24/hexo-not-found/" class="article-date">
  	<time datetime="2015-05-24T02:15:27.000Z" itemprop="datePublished">5月 24 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/24/hexo-not-found/">-bash:hexo:command not found</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>运行hexo命令时，发现如题这个错误。hexo是在之前安装好的。</p>
<p>后来发现原来是没有指定node.js所致。可以使用下面的方法解决：</p>
<p>可以使用下面命令解决：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm ls</span><br></pre></td></tr></table></figure></p>
<p>v0.12.3<br>node -&gt; stable (-&gt; v0.12.3) (default)<br>stable -&gt; 0.12 (-&gt; v0.12.3) (default)<br>iojs -&gt; iojs- (-&gt; N/A) (default)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm use v0.<span class="number">12.3</span></span><br></pre></td></tr></table></figure></p>
<p>Now using node v0.12.3 (npm v2.9.1)</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hexo/">hexo</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/解决方案/">解决方案</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 Ted Chen Visits <span id="busuanzi_value_site_pv"></span> Visitors <span id="busuanzi_value_site_uv"></span>
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/mobile.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>





<! -- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



  </div>
</body>
</html>